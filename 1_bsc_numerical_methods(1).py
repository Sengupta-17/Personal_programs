# -*- coding: utf-8 -*-
"""1-Bsc_numerical_methods.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gdFSPXlxEPs5mH6fb9_fcPT_wa30bITj
"""

#Qn1 Find 5th root of the Num-37 by Newton Raphson method
import math

def newton_raphson(x0, n, num):
  """
  Finds the nth root of a number using the Newton-Raphson method.

  Args:
    x0: Initial guess for the root.
    n: The root to find (e.g., 5 for the 5th root).
    num: The number to find the root of.

  Returns:
    The nth root of the number.
  """

  x1 = x0 - (x0**n - num) / (n * x0**(n - 1))
  while abs(x1 - x0) >= 1e-6:
    x0 = x1
    x1 = x0 - (x0**n - num) / (n * x0**(n - 1))
  return x1

# Find the 5th root of 37
x0 = 2  # Initial guess
n = 5
num = 37
root = newton_raphson(x0, n, num)
print("The 5th root of 37 is approximately:", root)

#Qn2 Find real root of f(x)_x^3 - 7x + 8 by Newton Raphson
def newton_raphson(x0, f, f_prime):
  """
  Finds a root of the equation f(x) = 0 using the Newton-Raphson method.

  Args:
    x0: Initial guess for the root.
    f: The function whose root we want to find.
    f_prime: The derivative of the function f.

  Returns:
    The root of the equation.
  """

  x1 = x0 - f(x0) / f_prime(x0)
  while abs(x1 - x0) >= 1e-6:
    x0 = x1
    x1 = x0 - f(x0) / f_prime(x0)
  return x1

# Define the function and its derivative
def f(x):
  return x**3 - 7*x + 8

def f_prime(x):
  return 3*x**2 - 7

# Initial guess
x0 = 1
# Find the root
root = newton_raphson(x0, f, f_prime)
print("The root of the equation x^3 - 7x + 8 = 0 is approximately:", root)

#Qn3 for the same problem do the coding for Bisection method
def bisection_method(f, a, b, tol=1e-6, max_iter=100):
  """
  Finds a root of the equation f(x) = 0 using the bisection method.

  Args:
    f: The function whose root we want to find.
    a: The left endpoint of the interval.
    b: The right endpoint of the interval.
    tol: The tolerance for the root.
    max_iter: The maximum number of iterations.

  Returns:
    The root of the equation.
  """

  if f(a) * f(b) >= 0:
    print("Bisection method fails. f(a) and f(b) must have opposite signs.")
    return None

  for i in range(max_iter):
    c = (a + b) / 2
    if abs(f(c)) < tol:
      return c
    elif f(a) * f(c) < 0:
      b = c
    else:
      a = c

  print("Maximum iterations reached. Solution may not be accurate.")
  return (a + b) / 2

# Define the function
def f(x):
  return x**3 - 4*x - 9

# Initial interval
a = 2
b = 3

# Find the root
root = bisection_method(f, a, b)
print("The root of the equation x^3 - 4x - 9 = 0 is approximately:", root)

#Qn4 Find eigen values of given matrix ([1,5,[2,3]])
import numpy as np

# Define the matrix
A = np.array([[1, 5], [2, 3]])

# Calculate the eigenvalues
eigenvalues, eigenvectors = np.linalg.eig(A)

print("Eigenvalues:", eigenvalues)
print("Eigenvectors:",eigenvectors)

import numpy as np

def power_method(A, max_iter=100, tol=1e-6):
  """
  Finds the dominant eigenvalue and eigenvector of a matrix A using the power method.

  Args:
    A: The input matrix.
    max_iter: Maximum number of iterations.
    tol: Tolerance for convergence.

  Returns:
    The dominant eigenvalue and eigenvector.
  """

  n, _ = A.shape
  x = np.ones(n)  # Initial guess for the eigenvector

  for _ in range(max_iter):
    y = np.dot(A, x)
    lambda_ = np.linalg.norm(y, ord=np.inf)
    x = y / lambda_

  return lambda_, x

# Define the matrix
A = np.array([[1, 5], [2, 3]])

# Find the dominant eigenvalue and eigenvector
eigenvalue, eigenvector = power_method(A)

print("Dominant eigenvalue:", eigenvalue)

import numpy as np

def power_method(A, max_iter=100, tol=1e-6):
  """
  Finds the dominant eigenvalue and eigenvector of a matrix A using the power method.

  Args:
    A: The input matrix.
    max_iter: Maximum number of iterations.
    tol: Tolerance for convergence.

  Returns:
    The dominant eigenvalue and eigenvector.
  """

  n, _ = A.shape
  x = np.array([1, 0])  # Initial guess for the eigenvector

  for _ in range(max_iter):
    y = np.dot(A, x)
    lambda_ = np.linalg.norm(y, ord=np.inf)
    x = y / lambda_

  return lambda_, x

# Define the matrix
A = np.array([[1, 5], [2, 3]])

# Find the dominant eigenvalue and eigenvector
eigenvalue, eigenvector = power_method(A)

print("Dominant eigenvalue:", eigenvalue)